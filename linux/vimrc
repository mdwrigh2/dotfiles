" Use VIM settings, rather than Vi settings
set nocompatible
set hidden

" Turn filetype plugins off so that they'll reload with pathogen bundles
filetype plugin off

" Start all of the bundles via pathogen
call pathogen#runtime_append_all_bundles()

" Turn on filetype based plugins
filetype plugin on

" Turn on line numbers
set nu

"Enable syntax highlighting
syntax on

" Auotmatically indent based on file type
set autoindent nocindent nosmartindent
filetype indent on

filetype on

" Case insensitive search (smartcase)
set ignorecase smartcase

" Highlight search
set hls

" Wrap text instead of being on one line
set lbr

" Turn the ruler on
set ruler

" Incremental search
set incsearch

" Remap Ctrl-N and Ctrl-P to :next and :previous, respectively
nnoremap <C-N> :next<Enter>
nnoremap <C-P> :previous<Enter>
set confirm

" Set indentation to spaces
set tabstop=8
set shiftwidth=4
set softtabstop=4
set expandtab

" Set the text width to 100 by default
set textwidth=100

" Prevents Vim 7.0 from setting filetype to 'plaintex'
let g:tex_flavor='latex'

" Set colorscheme
colorscheme molokai

" Mark trailing whitespace
set listchars=tab:\ \ ,trail:\ ,extends:»,precedes:«
if &background == "dark"
  highlight SpecialKey ctermbg=Red guibg=Red
else
  highlight SpecialKey ctermbg=Yellow guibg=Yellow
end


" Set go filetype
au BufNewFile,BufRead *.go set filetype=go

" Set sjs filetype
au BufNewFile,BufRead *.sjs set filetype=javascript
" Set njs filetype
au BufNewFile,BufRead *.njs set filetype=javascript
" Set asm to MASM
au BufNewFile,Bufread *.asm set filetype=masm
au BufNewFile,Bufread *.ASM set filetype=masm

" Setup the file type for EBNFs
au BufNewFile,BufRead *.ebnf set filetype=ebnf

" Setup the filetype for CoffeeScript
autocmd BufNewFile,BufRead *.coffee set filetype=coffee
autocmd BufNewFile,BufRead *Cakefile set filetype=coffee

  " Set indentation for Java according to Google Style Guide
au filetype java set tabstop=2 shiftwidth=2 softtabstop=2 expandtab tw=100

  " Set indentation for Python according to Google Style Guide
au FileType python set tabstop=2 shiftwidth=2 softtabstop=2 expandtab textwidth=80

  " Set indentation for Ruby according to Google Style Guide
au FileType ruby set tabstop=2 shiftwidth=2 expandtab

  " Set indentation for C according to Google Style Guide
au FileType c set tabstop=4 shiftwidth=4 expandtab

  " Set indentation for C++ according to Google Style Guide
au FileType cpp set tabstop=2 shiftwidth=2 expandtab

  " Set indentention for Make files
au FileType make set noexpandtab

  " Set indentation for Go files
au FileType go setlocal noexpandtab tabstop=4 softtabstop=4

  " Set indentation for HTML files
au FileType html set tabstop=2 shiftwidth=2 expandtab
au FileType xhtml set tabstop=2 shiftwidth=2 expandtab

  " Set settings for LaTeX files
au FileType tex SPCheck
au FileType tex let dialect='US'
au FileType tex set tabstop=2 shiftwidth=2 softtabstop=2 expandtab

" Set settings for XML files
au FileType xml set tabstop=4 shiftwidth=4 softtabstop=4 expandtab

" Ignore silly files
set wildignore=*.o,*.obj,*.bak,*.exe


" Set font
set gfn=Inconsolata\ 12

" Bind NERDTree commands
map <F2> :NERDTreeToggle<CR>

"Bind copy and paste to Ctrl-Shift-C/V
vnoremap <C-C> "+y
nnoremap <C-C> "+yy
noremap <C-V> "+p
imap <C-V> <Esc><C-V>a
cnoremap <C-V> <C-R>+
cnoremap <C-V> <C-R>+

" The trailing space is necessary for toggle comments. Not a very good binding, IMHO
map <C-x> <Leader>c 

" Setup Binary Editing Mode
" autocmds to automatically enter hex mode and handle file writes properly
if has("autocmd")
  " vim -b : edit binary using xxd-format!
  augroup Binary
    au!

    " set binary option for all binary files before reading them
    au BufReadPre *.bin,*.hex setlocal binary

    " if on a fresh read the buffer variable is already set, it's wrong
    au BufReadPost *
          \ if exists('b:editHex') && b:editHex |
          \   let b:editHex = 0 |
          \ endif

    " convert to hex on startup for binary files automatically
    au BufReadPost *
          \ if &binary | Hexmode | endif

    " When the text is freed, the next time the buffer is made active it will
    " re-read the text and thus not match the correct mode, we will need to
    " convert it again if the buffer is again loaded.
    au BufUnload *
          \ if getbufvar(expand("<afile>"), 'editHex') == 1 |
          \   call setbufvar(expand("<afile>"), 'editHex', 0) |
          \ endif

    " before writing a file when editing in hex mode, convert back to non-hex
    au BufWritePre *
          \ if exists("b:editHex") && b:editHex && &binary |
          \  let oldro=&ro | let &ro=0 |
          \  let oldma=&ma | let &ma=1 |
          \  silent exe "%!xxd -r" |
          \  let &ma=oldma | let &ro=oldro |
          \  unlet oldma | unlet oldro |
          \ endif

    " after writing a binary file, if we're in hex mode, restore hex mode
    au BufWritePost *
          \ if exists("b:editHex") && b:editHex && &binary |
          \  let oldro=&ro | let &ro=0 |
          \  let oldma=&ma | let &ma=1 |
          \  silent exe "%!xxd" |
          \  exe "set nomod" |
          \  let &ma=oldma | let &ro=oldro |
          \  unlet oldma | unlet oldro |
          \ endif
  augroup END
endif
